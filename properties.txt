Properties
I.memory writes
   a. when writing to arrays in memory or HW registers (program, boot, sha_in,
   sha_out, rsa_out, exp_reg_*), index should not exceed bounds (array out of
   bounds)
   b. RSA keys should only change during the key hash check/load step
II. locking
   a. input data to modules is locked while modules are running
   b. during the whole secureboot process, the RSA message register and write
   location is locked to outside processes
   c. in between when the header is checked and the program is loaded, the whole
   image is locked
III. program flow
   a. module that starts will finish
   b. either verification fails, or verification passes each stage and program
   is loaded, no skipping steps
IV. hyperproperties
   a. if # modules is the same, SP is always the same until verification fails
   b. if a memory address is locked, then nothing that the processor/attacker
   does will change the memory contents
   c. Image: src
      (range of addresses not in whitelist): dst
  
   d. mem_wr module: src
      (boot to boot+MAX_IM_SIZE): dst
      srcpred: (after the image is loaded into boot)
      
      mem_wr module: src
      (program to program+MAX_PRG_SIZE): dst
      srcpred: (after the RSA signature is verified and the modules are loaded, but before the hashes are verified).

   e. Untrusted module: src
      (boot to boot+MAX_IM_SIZE): dst
      srcpred: (after the image is loaded into boot)

      Untrusted module: src
      (program to program+MAX_PRG_SIZE): dst
      srcpred: (after the RSA signature is verified and the modules are loaded, but before the hashes are verified).
     
V. correctness of authenticated booth
  - hash(img.key) != hash_key => fail
      we verify this at the end of the execution

  - !verifySignature(img, img.key) => fail
      also at the end of the execution

  - for each module
      hash(module) != module.hash => fail
      also at the end of the execution

  - G(PC \in Known_PC_Locations)
      we will statically compute Known_PC_Locations beforehand.

Notes:
 - circular reasoning because the image contains the key and we sign it using the key? 

    (verifySignature(img, img.key) && hash(img.key) == hash(true_key)) => verifySignature(img, true_key)
      hash(img.key) == hash(true_key) => img.key == true_key

 - modules is loaded between 0x0000 and 0x5000

TODO
 x lock 'boot' right after loading.
 x then verify signature in boot
 x lock 'program' after we load each module into it.
 x then verify hashes
 - lock hashes after they are computed, but before they are verified.

Whitelist
 - all the hardware registers
 - modules (0x0000 - 0x5000)
 - __xdata __at(0x0000) unsigned char program[MAX_PRG_SIZE];
 - __xdata __at(0xE080) unsigned char sha_out[20];
 - __xdata __at(0xE100) unsigned char rsa_out[N];
 - a property that says that all regions outside this range are never modified.
